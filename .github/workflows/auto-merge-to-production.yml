name: Auto-merge master to production

on:
  push:
    branches: [ master ]
  # Allow manual trigger for testing
  workflow_dispatch:

jobs:
  check-tests:
    runs-on: ubuntu-latest
    outputs:
      tests-passed: ${{ steps.check-status.outputs.tests-passed }}
    steps:
      - name: Check if tests passed
        id: check-status
        uses: actions/github-script@v7
        with:
          script: |
            // Get commit statuses (this is where CircleCI reports)
            const { data: statuses } = await github.rest.repos.listCommitStatusesForRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: context.sha
            });
            
            console.log(`Found ${statuses.length} commit statuses for commit ${context.sha}`);
            
            // Also get check runs in case CircleCI uses both
            const { data: checkRuns } = await github.rest.checks.listForRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: context.sha
            });
            
            console.log(`Found ${checkRuns.check_runs.length} check runs for commit ${context.sha}`);
            
            // Look for CircleCI in commit statuses (typical format: "ci/circleci: build-and-test")
            const circleciStatuses = statuses.filter(status => 
              status.context.includes('circleci') && status.context.includes('build-and-test')
            );
            
            // Also look for CircleCI in check runs
            const circleciChecks = checkRuns.check_runs.filter(check => 
              check.name.includes('circleci') || 
              check.name.includes('build-and-test') ||
              check.app?.name === 'CircleCI'
            );
            
            console.log(`Found ${circleciStatuses.length} CircleCI commit statuses`);
            console.log(`Found ${circleciChecks.length} CircleCI check runs`);
            
            // Log what we found - show most recent status first
            console.log('=== CircleCI Commit Statuses ===');
            circleciStatuses.forEach((status, index) => {
              console.log(`${index}: ${status.context} - ${status.state} - ${status.description} (${status.created_at})`);
            });
            
            console.log('=== CircleCI Check Runs ===');
            circleciChecks.forEach((check, index) => {
              console.log(`${index}: ${check.name} - ${check.status}/${check.conclusion} (${check.started_at})`);
            });
            
            if (circleciStatuses.length === 0 && circleciChecks.length === 0) {
              console.log('No CircleCI checks found, tests may still be running');
              core.setOutput('tests-passed', 'false');
              return;
            }
            
            // For commit statuses, get the latest status (they're returned in reverse chronological order)
            const latestCircleCIStatus = circleciStatuses.length > 0 ? circleciStatuses[0] : null;
            
            if (latestCircleCIStatus) {
              console.log(`Latest CircleCI status: ${latestCircleCIStatus.state} - ${latestCircleCIStatus.description}`);
              
              if (latestCircleCIStatus.state === 'success') {
                console.log('CircleCI tests passed!');
                core.setOutput('tests-passed', 'true');
                return;
              } else if (latestCircleCIStatus.state === 'pending') {
                console.log('CircleCI tests are still running');
                core.setOutput('tests-passed', 'false');
                return;
              } else if (latestCircleCIStatus.state === 'failure' || latestCircleCIStatus.state === 'error') {
                console.log('CircleCI tests failed');
                core.setOutput('tests-passed', 'false');
                return;
              }
            }
            
            // Fallback to check runs if no commit statuses
            const checksAllPassed = circleciChecks.every(check => check.conclusion === 'success');
            const checksAnyRunning = circleciChecks.some(check => check.status === 'in_progress' || check.status === 'queued');
            const checksAnyFailed = circleciChecks.some(check => check.conclusion === 'failure');
            
            if (checksAnyRunning) {
              console.log('Some check runs are still running');
              core.setOutput('tests-passed', 'false');
            } else if (checksAnyFailed) {
              console.log('Some check runs failed');
              core.setOutput('tests-passed', 'false');
            } else if (checksAllPassed && circleciChecks.length > 0) {
              console.log('All check runs passed!');
              core.setOutput('tests-passed', 'true');
            } else {
              console.log('Tests status unclear, will wait');
              core.setOutput('tests-passed', 'false');
            }

  wait-for-tests:
    runs-on: ubuntu-latest
    needs: check-tests
    if: needs.check-tests.outputs.tests-passed == 'false'
    steps:
      - name: Wait for tests to complete
        uses: actions/github-script@v7
        with:
          script: |
            const maxWaitTime = 60 * 60 * 1000; // 60 minutes
            const checkInterval = 30 * 1000; // 30 seconds
            const startTime = Date.now();
            
            while (Date.now() - startTime < maxWaitTime) {
              console.log('Checking test status...');
              
              // Get commit statuses (where CircleCI reports)
              const { data: statuses } = await github.rest.repos.listCommitStatusesForRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: context.sha
              });
              
              // Also get check runs as backup
              const { data: checkRuns } = await github.rest.checks.listForRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: context.sha
              });
              
              const circleciStatuses = statuses.filter(status => 
                status.context.includes('circleci') && status.context.includes('build-and-test')
              );
              
              const circleciChecks = checkRuns.check_runs.filter(check => 
                check.name.includes('circleci') || 
                check.name.includes('build-and-test') ||
                check.app?.name === 'CircleCI'
              );
              
              console.log(`Found ${circleciStatuses.length} CircleCI statuses, ${circleciChecks.length} CircleCI check runs`);
              
              if (circleciStatuses.length === 0 && circleciChecks.length === 0) {
                console.log('No CircleCI checks found yet, continuing to wait...');
                await new Promise(resolve => setTimeout(resolve, checkInterval));
                continue;
              }
              
              // Check the latest CircleCI commit status first (most reliable)
              const latestCircleCIStatus = circleciStatuses.length > 0 ? circleciStatuses[0] : null;
              
              if (latestCircleCIStatus) {
                console.log(`Latest CircleCI status: ${latestCircleCIStatus.state} - ${latestCircleCIStatus.description}`);
                
                if (latestCircleCIStatus.state === 'success') {
                  console.log('CircleCI tests passed!');
                  return;
                } else if (latestCircleCIStatus.state === 'failure' || latestCircleCIStatus.state === 'error') {
                  console.log('CircleCI tests failed');
                  core.setFailed('Tests failed');
                  return;
                } else if (latestCircleCIStatus.state === 'pending') {
                  console.log('CircleCI tests still running, waiting...');
                  await new Promise(resolve => setTimeout(resolve, checkInterval));
                  continue;
                }
              }
              
              // Fallback to check runs
              const checksAllPassed = circleciChecks.every(check => check.conclusion === 'success');
              const checksAnyFailed = circleciChecks.some(check => check.conclusion === 'failure');
              const checksAnyRunning = circleciChecks.some(check => check.status === 'in_progress' || check.status === 'queued');
              
              const allPassed = latestCircleCIStatus ? false : checksAllPassed; // Only use check runs if no commit status
              const anyFailed = checksAnyFailed;
              const anyRunning = checksAnyRunning;
              
              if (allPassed) {
                console.log('All tests passed!');
                return;
              } else if (anyFailed) {
                console.log('Tests failed, will not merge to production');
                core.setFailed('Tests failed');
                return;
              } else if (anyRunning) {
                console.log('Tests still running, waiting...');
                await new Promise(resolve => setTimeout(resolve, checkInterval));
              } else {
                console.log('Tests completed with unknown status');
                core.setFailed('Tests completed with unknown status');
                return;
              }
            }
            
            console.log('Timeout waiting for tests to complete');
            core.setFailed('Timeout waiting for tests to complete');

  merge-to-production:
    runs-on: ubuntu-latest
    needs: [check-tests, wait-for-tests]
    if: always() && (needs.check-tests.outputs.tests-passed == 'true' || needs.wait-for-tests.result == 'success') && !(needs.wait-for-tests.result == 'failure')
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Merge master to production
        run: |
          # Fetch all branches
          git fetch origin
          
          # Check out production branch
          git checkout production || git checkout -b production origin/production
          
          # Merge master into production
          git merge origin/master --no-ff -m "Auto-merge master to production after successful tests

          Merged commit: ${{ github.sha }}
          Triggered by: ${{ github.event_name }}
          
          ðŸ¤– Automated merge by GitHub Actions"
          
          # Push to production
          git push origin production

      - name: Create merge summary
        uses: actions/github-script@v7
        with:
          script: |
            const { data: commit } = await github.rest.repos.getCommit({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: context.sha
            });
            
            const message = `âœ… Successfully merged master to production branch
            
            **Commit:** ${context.sha.substring(0, 7)}
            **Message:** ${commit.commit.message.split('\n')[0]}
            **Author:** ${commit.commit.author.name}
            **Tests:** All CircleCI tests passed
            
            The production branch has been updated and should trigger deployment.`;
            
            console.log(message);