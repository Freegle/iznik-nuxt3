default_platform(:android)

platform :android do
  desc "Build and deploy to Google Play Beta Testing"
  lane :beta do
    # Validate that Google Play API key file exists
    unless File.exist?('google-play-api-key.json')
      UI.user_error!("‚ùå CRITICAL: Google Play API key file not found at google-play-api-key.json")
      UI.user_error!("üí° Ensure GOOGLE_PLAY_JSON_KEY environment variable is set in CircleCI")
    end

    # Validate that the file is valid JSON
    begin
      json_key_data = JSON.parse(File.read('google-play-api-key.json'))
      if json_key_data.empty?
        UI.user_error!("‚ùå CRITICAL: Google Play API key file is empty")
      end
      UI.success("‚úÖ Google Play API key file validated")
    rescue JSON::ParserError => e
      UI.user_error!("‚ùå CRITICAL: Google Play API key file is not valid JSON: #{e.message}")
    end

    # Get and auto-increment version NAME from CircleCI environment variable
    # This avoids needing git push permissions
    current_version = ENV['CURRENT_VERSION']

    unless current_version
      UI.user_error!("‚ùå CRITICAL: CURRENT_VERSION environment variable not set in CircleCI")
      UI.user_error!("üí° Set it in CircleCI Project Settings ‚Üí Environment Variables")
      UI.user_error!("üí° Format: X.Y.Z (e.g., 3.2.28)")
    end

    UI.message("üì± Current version from CircleCI: #{current_version}")

    # Validate and parse version format
    parts = current_version.split('.').map(&:to_i)
    unless parts.length == 3
      UI.user_error!("‚ùå CRITICAL: Invalid version format '#{current_version}'. Expected format: X.Y.Z")
    end

    # Auto-increment patch version
    parts[2] += 1
    version = parts.join('.')
    UI.success("üì± Auto-incremented version name: #{current_version} ‚Üí #{version}")

    # Write new version to file for CircleCI to read
    File.write('../.new_version', version)
    UI.success("‚úÖ Wrote new version to .new_version file")

    # Get version code from Google Play API
    # Check ALL tracks to find the maximum version code to avoid conflicts
    all_version_codes = []

    ['internal', 'beta', 'production'].each do |track|
      begin
        version_codes = google_play_track_version_codes(
          track: track,
          json_key: 'fastlane/google-play-api-key.json'
        )

        if version_codes && version_codes.any?
          max_for_track = version_codes.max
          all_version_codes << max_for_track
          UI.message("üìä #{track.capitalize} track max version code: #{max_for_track}")
        else
          UI.message("‚ÑπÔ∏è  No releases in #{track} track")
        end
      rescue => e
        UI.message("‚ÑπÔ∏è  Could not fetch #{track} track version codes: #{e.message}")
      end
    end

    # Fail if we couldn't get version code from any track
    if all_version_codes.empty?
      UI.user_error!("‚ùå CRITICAL: Could not fetch version codes from any Google Play track")
      UI.user_error!("üí° Ensure at least one release exists in Google Play (any track)")
      UI.user_error!("üí° Check that service account has 'View app information' permission")
    end

    latest_build = all_version_codes.max
    new_version_code = latest_build + 1
    UI.success("üìä Maximum version code across all tracks: #{latest_build}")
    UI.success("üìä New version code: #{new_version_code}")

    # Build the Android App Bundle (AAB) for Play Store
    gradle(
      task: 'bundle',
      build_type: 'Release',
      project_dir: 'android/',
      properties: {
        "versionName" => version,
        "versionCode" => new_version_code.to_s
      },
      flags: '--stacktrace'  # Enable stack traces for debugging
    )

    # Also build APK for direct installation and testing
    gradle(
      task: 'assemble',
      build_type: 'Release',
      project_dir: 'android/',
      properties: {
        "versionName" => version,
        "versionCode" => new_version_code.to_s
      },
      flags: '--stacktrace'  # Enable stack traces for debugging
    )
    UI.success("‚úÖ APK built successfully for manual installation!")
    UI.message("üì± APK location: android/app/build/outputs/apk/release/app-release.apk")

    # Create changelog for this release
    # Fastlane expects changelogs in metadata/android/{locale}/changelogs/{version_code}.txt
    changelog_dir = '../fastlane/metadata/android/en-US/changelogs'
    FileUtils.mkdir_p(changelog_dir)
    changelog_file = "#{changelog_dir}/#{new_version_code}.txt"
    File.write(changelog_file, "Version #{version} - Bug fixes and improvements")
    UI.success("‚úÖ Created changelog for version code #{new_version_code}")

    # Upload to Google Play Beta Testing track
    upload_to_play_store(
      track: 'beta',
      json_key: 'fastlane/google-play-api-key.json',
      skip_upload_apk: true,
      skip_upload_images: true,
      skip_upload_screenshots: true
    )
    UI.success("‚úÖ Successfully uploaded to Google Play Beta Testing!")
  end

  desc "Promote Internal to Beta"
  lane :promote_beta do
    upload_to_play_store(
      track: 'internal',
      track_promote_to: 'beta',
      json_key: 'fastlane/google-play-api-key.json',
      skip_upload_apk: true,
      skip_upload_aab: true
    )
  end

  desc "Promote Beta to Production"
  lane :promote_production do
    upload_to_play_store(
      track: 'beta',
      track_promote_to: 'production',
      json_key: 'fastlane/google-play-api-key.json',
      skip_upload_apk: true,
      skip_upload_aab: true
    )
  end

  desc "Auto-promote beta to production after 24 hours"
  lane :auto_promote do
    require 'googleauth'
    require 'google/apis/androidpublisher_v3'
    require 'time'

    UI.message("üîç Checking beta track for releases ready to promote...")

    json_key_data = JSON.parse(File.read('google-play-api-key.json'))
    credentials = Google::Auth::ServiceAccountCredentials.make_creds(
      json_key_io: StringIO.new(json_key_data.to_json),
      scope: 'https://www.googleapis.com/auth/androidpublisher'
    )

    service = Google::Apis::AndroidpublisherV3::AndroidPublisherService.new
    service.authorization = credentials

    # Get the edit
    edit = service.insert_edit('org.ilovefreegle.direct')
    edit_id = edit.id

    begin
      # Get beta track
      beta_track = service.get_edit_track('org.ilovefreegle.direct', edit_id, 'beta')

      if beta_track.releases && beta_track.releases.any?
        latest_release = beta_track.releases.first

        # Check if release has a user fraction (staged rollout) or is completed
        if latest_release.status == 'completed' || latest_release.status == 'inProgress'
          version_codes = latest_release.version_codes
          UI.message("üì¶ Found beta release with version codes: #{version_codes.join(', ')}")

          # Get production track to check if already promoted
          production_track = service.get_edit_track('org.ilovefreegle.direct', edit_id, 'production')
          production_version_codes = []
          if production_track.releases && production_track.releases.any?
            production_version_codes = production_track.releases.first.version_codes || []
          end

          # Check if beta version is already in production
          if version_codes.all? { |vc| production_version_codes.include?(vc) }
            UI.message("‚úÖ Beta release already promoted to production")
            service.delete_edit('org.ilovefreegle.direct', edit_id)
            next
          end

          # Note: Google Play API doesn't expose exact publish timestamp
          # We'll use a simpler approach: check if there's a beta release that's not in production
          # and assume it's been there for 24 hours if this workflow runs daily

          # For now, we'll just check once per day and promote
          # A more sophisticated approach would track versions in a file/database
          hours_since_release = ENV['HOURS_SINCE_RELEASE'] || '24'

          UI.success("üöÄ Promoting beta to production after #{hours_since_release} hours...")

          # Delete current edit and create new one for promotion
          service.delete_edit('org.ilovefreegle.direct', edit_id)

          # Promote to production
          promote_production

          UI.success("‚úÖ Successfully promoted beta to production!")
        else
          UI.message("‚ÑπÔ∏è  Beta release status: #{latest_release.status} - not ready for promotion")
        end
      else
        UI.message("‚ÑπÔ∏è  No releases found in beta track")
      end
    rescue => e
      UI.error("‚ùå Error checking beta track: #{e.message}")
      service.delete_edit('org.ilovefreegle.direct', edit_id) rescue nil
      raise e
    end
  end
end

platform :ios do
  desc "Build and upload to TestFlight"
  lane :beta do
    # Validate environment variables
    unless ENV['APP_STORE_CONNECT_API_KEY_KEY_ID']
      UI.user_error!("‚ùå CRITICAL: APP_STORE_CONNECT_API_KEY_KEY_ID not set")
    end
    unless ENV['APP_STORE_CONNECT_API_KEY_ISSUER_ID']
      UI.user_error!("‚ùå CRITICAL: APP_STORE_CONNECT_API_KEY_ISSUER_ID not set")
    end
    unless ENV['APP_STORE_CONNECT_API_KEY_KEY']
      UI.user_error!("‚ùå CRITICAL: APP_STORE_CONNECT_API_KEY_KEY not set")
    end

    # Set up App Store Connect API Key
    app_store_connect_api_key(
      key_id: ENV['APP_STORE_CONNECT_API_KEY_KEY_ID'],
      issuer_id: ENV['APP_STORE_CONNECT_API_KEY_ISSUER_ID'],
      key_content: Base64.decode64(ENV['APP_STORE_CONNECT_API_KEY_KEY']),
      is_key_content_base64: false
    )

    # Get version from CircleCI environment variable (same as Android)
    current_version = ENV['CURRENT_VERSION']
    unless current_version
      UI.user_error!("‚ùå CRITICAL: CURRENT_VERSION environment variable not set")
    end

    UI.message("üì± Current version from CircleCI: #{current_version}")

    # Auto-increment patch version (matching Android logic)
    parts = current_version.split('.').map(&:to_i)
    unless parts.length == 3
      UI.user_error!("‚ùå CRITICAL: Invalid version format '#{current_version}'")
    end

    parts[2] += 1
    version = parts.join('.')
    UI.success("üì± Auto-incremented version: #{current_version} ‚Üí #{version}")

    # Write new version to file for CircleCI to read (same as Android)
    File.write('../.new_version', version)
    UI.success("‚úÖ Wrote new version to .new_version file")

    # Set version number in Xcode
    increment_version_number(
      version_number: version,
      xcodeproj: "ios/App/App.xcodeproj"
    )

    # Get latest TestFlight build number
    begin
      latest_build = latest_testflight_build_number(
        version: version,
        initial_build_number: 0,
        app_identifier: "org.ilovefreegle.iphone"
      )
      UI.message("üìä Latest TestFlight build for v#{version}: #{latest_build}")
    rescue => e
      UI.message("‚ÑπÔ∏è  No existing builds for v#{version}, starting at 0")
      latest_build = 0
    end

    new_build = latest_build + 1
    UI.success("üìä New build number: #{new_build}")

    # Set build number in Xcode
    increment_build_number(
      build_number: new_build,
      xcodeproj: "ios/App/App.xcodeproj"
    )

    # Get code signing certificates via Match
    # This will create new certificates on first run
    match(
      type: "appstore",
      readonly: false,
      app_identifier: "org.ilovefreegle.iphone"
    )

    # Build the app
    gym(
      scheme: "App",
      workspace: "ios/App/App.xcworkspace",
      export_method: "app-store",
      export_options: {
        provisioningProfiles: {
          "org.ilovefreegle.iphone" => "match AppStore org.ilovefreegle.iphone"
        }
      },
      clean: true,
      output_directory: "./build"
    )

    # Upload to TestFlight
    pilot(
      skip_waiting_for_build_processing: true,
      distribute_external: false,
      changelog: "Version #{version} - Bug fixes and improvements",
      app_identifier: "org.ilovefreegle.iphone"
    )

    UI.success("‚úÖ Successfully uploaded to TestFlight!")
  end

  desc "Promote TestFlight to Production"
  lane :release do
    app_store_connect_api_key(
      key_id: ENV['APP_STORE_CONNECT_API_KEY_KEY_ID'],
      issuer_id: ENV['APP_STORE_CONNECT_API_KEY_ISSUER_ID'],
      key_content: Base64.decode64(ENV['APP_STORE_CONNECT_API_KEY_KEY']),
      is_key_content_base64: false
    )

    deliver(
      submit_for_review: true,
      automatic_release: false,
      force: true,
      skip_metadata: true,
      skip_screenshots: true,
      precheck_include_in_app_purchases: false,
      app_identifier: "org.ilovefreegle.iphone"
    )

    UI.success("‚úÖ Submitted for App Store review!")
  end
end
